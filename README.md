# Memory Management Unit Project using Scheme

## 1. Introduction

This project involves the implementation of a simple Memory Management Unit (MMU). The MMU acts as an intermediary between the Central Processing Unit (CPU) and the main memory. Its primary function is to translate logical (virtual) addresses generated by the CPU into physical addresses.

## 2. Memory Management Unit

The MMU is responsible for mapping logical addresses to physical addresses. It achieves this through various mechanisms, including the use of relocation and limit registers, as well as paging. Paging allows for non-contiguous memory allocation by dividing the address space into fixed-size blocks called pages.

## 3. How to Run

To run the project:

1. Clone this repository to your local machine.
2. Ensure you have Racket installed and added to your PATH.
3. Open `main.rkt` in your preferred Racket IDE.
4. Compile and run the code.

## 4. Procedures

Nine procedures are to be implemented to simulate the MMU's functionality. Here are the key procedures:

### 3.1 `binary_to_decimal`
Converts a binary number to its decimal equivalent.

### 3.2 `relocator`
Maps logical addresses to physical addresses based on relocation and limit registers.

### 3.3 `divide_address_space`
Divides a logical address into page number and page offset.

### 3.4 `page`
Maps logical addresses to physical addresses using paging.

### 3.5 `find_sin`
Calculates the sine of an angle using Taylor series expansion.

### 3.6 `myhash`
Computes the hash value of a binary number.

### 3.7 `hashed_page`
Maps logical addresses to physical addresses using a hashed page table.

### 3.8 `split_addresses`
Splits a stream of logical addresses into smaller chunks.

### 3.9 `map_addresses`
Maps logical addresses to physical addresses using a hashed page table.